% !TeX spellcheck = <none>
\chapter{Desenvolvimento}
\label{chap:desen_test}
\begin{flushright}
	"Insanidade é continuar fazendo sempre as mesmas coisas, \\ 
	esperando resultados diferentes." \\
	\ \\
	(Albert Einstein)
\end{flushright}

Durante cada uma das etapas da metodologia, uma série de tarefas foram elaboradas e cumpridas. Este capítulo irá tratar do desenvolvimento de cada dessas etapas de acordo com a metodologia utilizada na realização deste projeto.

\section{Etapa Conceitual}
\subsection{Levantamento de Requisitos}
O primeiro passo para o desenvolvimento do projeto foi o de reunir todos os requisitos que deveriam ser cumpridos pelas entregas. A partir de conversas com o cliente, pode-se levantar alguns requisitos iniciais.

As funcionalidades esperadas pelo cliente foram um kit físico dividido em módulos integrados e complementares. O kit deveria culminar na montagem de um robô com movimentação cinemática e funcionalidade de visão computacional utilizando uma câmera RGB.
 
Além disso o cliente esperava também tutoriais online abrigados em domínio aberto, escritos em linguagem simplificada, abordando conceitos introdutórios da robótica, como por exemplo: O que é um robô, partes de um robô, funcionalidades de um robô completo, áreas da robótica e suas funcionalidades, atuação e movimentação diferencial, introdução a visão computacional e integração com a movimentação.

Um outro ponto exigido pelo cliente foi a utilização de desafios ao longo do desenvolvimento através do kit, com o intuito de manter o estudante engajado e interessado durante a sua interação com o kit.

Por fim o cliente pediu ainda que fossem abordados conceitos de ferramentas utilizadas profissionalmente, em específico o framework ROS, alguma linguagem de programação e alguma biblioteca para auxilio de aprendizado na questão da visão computacional.

\subsection{Estudo do Estado da Arte}
De posse dos requisitos do projeto, o próximo passo foi realizar uma pesquisa sobre as principais tecnologias e projetos já existentes, tanto no Brasil quanto no mundo que cumpriam parcialmente ou totalmente com os requisitos levantados. Os principais envolvidos encontrados foram 
\subsection{Estudo das Metodologias de Ensino}

\section{Projeto Detalhado}
\subsection{Definição}
Após a realização das etapas descritas anteriormente, pôde-se de fato escrever uma solução proposta. A solução proposta foi dividida em duas partes, o Kit Físico e os Tutoriais, como descrito a seguir.

Kit Físico: Utilização da Raspberry Pi como controlador central, utilização dos dynamixels mx-28 como atuadores, kit modulado com módulos integrados e sequenciais para montagem de um robô reconhecedor de marcos fiduciais. A finalização do Kit culminará em um robô com movimentação diferencial e capacidade de visão com a utilização de uma câmera RGB. Todos os componentes podem ser  visto na tabela \ref{Tabela1}:

\begin{table}
	\centering
	\begin{small}
		\caption{Componentes constituintes do kit fisíco.} \label{Tabela1}
		\begin{tabular}{cc}
			\hline
			Componentes              & Quantidade\\
			\hline
			Raspberry Pi3B              & 1 \\
			Dynamixel MX-28                & 2 \\
			Câmera RGB                    & 1 \\
			Rodas emborrachadas            & 2 \\
			Roda boba                    & 1 \\
			Cabos e conexões            & x \\
			Bateria                     & 1 \\
			Conversores DCDC            & 2 \\
			\hline
		\end{tabular}
	\end{small}
\end{table}

Tutoriais: Linguagem simples e acessível, metodologia intuitiva, presença de desafios.
Conteúdos a serem abordados: Breve histórico da robótica, partes de um robô, funcionalidades encontradas em robôs completos, introdução a áreas da robótica, abordagem prática do framework ROS em compatibilidade com a Raspberry Pi, abordagem prática de conceitos de programação em Python com a utilização de programas modelos acompanhados de tutoriais de mudança e proposição de desafios,
programação de atuação dos servos para movimentação diferencial simples, abordando conceitos facilitados de cinemática diferencial e seu funcionamento. Introdução à visão computacional com introdução a biblioteca do OpenCV e tratamentos simples de imagens.
Implementação de uma integração da movimentação com a visão computacional.

\subsubsection{Metodologia de ensino}
A partir da análise das metodologias de ensino préviamente apresentadas, a equipe pensou em uma proposta metodológica que contivesse dois pilares filosofico, teoria e prática. A figura \ref{img:rep_metod} representa graficamente a proposta metodologica, evidenciando como os pilares se relacionam.
\begin{figure}[h!]                                                
	\centering        
	\includegraphics[width=0.8\textwidth]{fluxograma_metodo.png}            
	\caption{Representação Gráfica da Metodologia}        
	\label{img:rep_metod}    
	\source{Autores, 2019}        
\end{figure}
Os dois pilares filosoficos são subdivididos da seguinte maneira: Na parte teórica serão apresentados ao estudante conceitos básicos de robótica, baseados nas principais bibliografias e documentos que são normalmente utilizados pela comunidade de robótica.

Do ponto de vista teórico, um exemplo do que será disponibilizado são os tutoriais do Framework ROS (do inglês Robot Operating System), que são elaborados pela própria comunidade do ROS. Todavia, não existem versões escritas em português, ou em uma linguagem que se preocupe em ser simplificada, o que dificulta o acesso à essas informações. Assim, a proposta é de utilizar estes tutoriais como inspiração e referência de conteúdo para produção de material escrito em linguagem mais acessível e em português.

Além da produção de tutoriais, há ainda a proposta de apresentar scripts modelo, escritos em python, que servirão como base para explicações dos conceitos. O foco destes, será mostrar aos alunos como utilizar métodos e funções próprias do framework. Estes scripts estarão envolvidos diretamente com outro item, que é o aprendizado prático. A parte prática tem como foco o estudo e a alteração dos scripts, proporcionando assim o desenvolvimento do estudante em programação.

Cada script modelo estará atrelado a um desafio. Para que o estudante solucione estes desafios, a proposta é que ele leia, interprete e altere o programa para realizar uma tarefa específica que vai um pouco além da apresentada pelo script original.

Visando dar forma e visual à conceitos muitas vezes abstratos, o que é interessante na abordagem, é que, atrelado a essas alterações haverão dispositivos reais para demonstrar se houve ou não êxito. Alguns exemplos de dispositivos com os quais os estudantes poderão interagir são servomotores e uma câmera, o que
facilitará uma absorção dos conceitos apresentados.

O pilar filosofico da teoria é suportado pela plataforma Github, mais precisamente as páginas contidas nela. Esta plataforma é considerada  \textit{Opensource}, ou seja, toda informação disposta nela é aberta para o público, cumprindo assim o desejo da equipe de democratizar o conhecimento. Ao todo existem 24 páginas com conteúdos diversos nesta plataforma, além de 12 programas modelos.

Paralelo à isso, na parte física, o estudante também terá um kit físico para montagem gradual de um robô com movimentação diferencial. Esta montagem será modular e será regida pelo seu andamento nos tutoriais. O quadro \ref{Tabela1} apresenta os componentes presentes no kit.

\begin{table}
	\centering
	\begin{small}
		\caption{Componentes constituintes do kit fisíco.} \label{Tabela1}
		\begin{tabular}{cc}
			\hline
			Componentes              & Quantidade\\
			\hline
			Raspberry Pi3B              & 1 \\
			Dynamixel MX-28                & 2 \\
			Câmera RGB                    & 1 \\
			Rodas emborrachadas            & 2 \\
			Roda boba                    & 1 \\
			Cabos e conexões            & x \\
			Bateria                     & 1 \\
			Conversores DCDC            & 2 \\
			\hline
		\end{tabular}
	\end{small}
\end{table}
A escolha da Raspberry Pi 3.0B se deve por conta da alta disponibilidade no mercado, por apresentar um custo baixo se comparado com outros computadores que serviriam para a mesma finalidade, e principalmente por apresentar poder computacional suficiente para o funcionamento do ROS e das bibliotecas de processamento de imagens que serão utilizadas.

Na Raspberry Pi será utilizado o sistema operacional Raspbian por ser o mais otimizado para a plataforma, por ser derivado de um sistema Linux, e por funcionar
aliado ao ROS Kinetic, que é hoje a distribuição do ROS mais utilizada pela comunidade da robótica.

O estudante irá receber a Raspberry com todas as bibliotecas necessárias para funcionamento e alteração dos scripts já instaladas, assim como o framework também já instalado, poupando assim o desestímulo inicial que tende a ocorrer no primeiro contato com estas ferramentas.

Serão apresentados os servomotores Dynamixel, por serem amplamente utilizados em projetos robóticos de inovação. Isso ocorre por conta da maior facilidade de integrar estes servos com o ROS, sem precisar utilizar ferramentas mais complexas, como desenvolvimento de drivers e controle PWM (do inglês, Pulse Width Modulation). Em um dos scripts modelo, por exemplo, irá ser apresentada a forma de se comunicar com os servos, juntamente à introdução da cinemática de robôs diferenciais.

A câmera RGB será utilizada para facilitar a introdução de conceitos de visão computacional e suas ferramentas, como a biblioteca do OpenCV (do inglês, Open Computer Vision). Haverão scripts modelo apresentando a integração entre ROS e OpenCV, além da proposição de desafios utilizando conceitos básicos de visão computacional.

A figura \ref{img:flu_metod} apresenta o fluxograma da proposta de aprendizagem de robótica feita pela equipe. Ela representa como o aluno irá aprender a robótica utilizando os materiais dispostos, de forma modular e progressiva. 
Este quesito de ser progressivo e modular é representado nos passos da figura \ref{img:flu_metod}, já que inicialmente o aluno irá aprender os conceitos básicos dispostos na wiki. Cada conceito básico tem um programa modelo para exemplificar e demonstrar como este conceito é aplicado na robótica. Após a apresentação do programa modelo, é proposto um desafio ao aluno envolvendo o conceito abordado. Para o comprimento deste desafio, o estudante necessita montar uma parte do kit físico a fim de propiciar a parte prática e o contato com o hardware. Com a teoria que foi apresentada anteriormente, programa modelo e pesquisa em textos base, o aluno será capaz de solucionar o desafio proposto anteriormente. Com a assimilação do conteúdo, o usuário será apto para passar para um conceito mais complexo da área da robótica.


\begin{figure}[h!]                                                
	\centering        
	\includegraphics[width=0.8\textwidth]{fluxograma_met.png}            
	\caption{Fluxograma da Metodologia}        
	\label{img:flu_metod}    
	\source{Autores, 2019}        
\end{figure}

\subsection{Planejamento}

\section{Confecção}
\subsection{Protótipo Físico}
O Kit Físico foi pensado para ser uma forma de concretização dos conceitos abstratos que são abordados ao longo dos tutoriais. A ideia foi de criar um robô que funcionaria a partir de movimentação diferencial e que fosse capaz de trabalhar com os conceitos de cinematica e visão computacional em conjunto.

De forma a otimizar o design do robô, algumas considerações iniciais foram levantadas anteriormente ao inicio do design:

\begin{itemize}
	\item O robô deve ser compacto;
	\item O robô deve ser apresentar boa resistência mecânica em geral;
	\item O robô será majoritariamente fabricado por manufatura aditiva;
	\item O robô deve ser composto por peças para montagem gradual;
\end{itemize}
A partir destes detalhes iniciou-se o design do robô. Utilizou-se o software SOLIDWORKS 2019 para criar o design de forma interativa. As geometrias buscadas tem características modernas e foram pensadas também para serem eficazes no que concerne a fabricação por manufatura aditiva.

Tomando como base o componente de maior peso e volume do sistema, a bateria, foi criada a peça "Chassi 1" para mantê-la na região central e deixar o motor equilibrado com um centro de gravidade centralizado e baixo. A imagem~\ref{fig:chassi_1} abaixo representa essa peça.

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm, height=8cm, angle=0]{chassi_1.jpg}\\
	\caption{Peça Chassi 1 \\ Fonte: Autores, 2019}
	\label{fig:chassi_1}
\end{figure}

O rebaixo feito no principal chassi foi feito para manter a bateria encaixada e evitar seu movimento durante o deslocamento do sistema. Além disso, em diversas partes do design do robô, utilizou-se o conceito de Poka Yoke para que o encaixe das peças seja intuitivo e erros sejam prevenidos no momento da montagem. Isso pode ser visto nos quatro furos cilíndricos no chassi que servirão unicamente para encaixar os pinos de peças que se encaixam ao chassi. Na parte frontal do Chassi também existem entradas para que o Chassi 2 se acople a ele.

O segundo componente a ser criado foi o suporte do Dynamixel, que será responsável por fixar os servomotores ao chassi principal. Este componente é simples e foi feito para se encaixar perfeitamente no Dynamixel, com furo para passagem do eixo e pinos
para encaixe, como demonstrado na figura~\ref{fig:suport_dyn} abaixo.

\begin{figure}[h!]
	\centering
	\includegraphics[width=7cm, height=8cm, angle=0]{suport_dyn.jpg}\\
	\caption{Peça Suporte Dynamixel \\ Fonte: Autores, 2019}
	\label{fig:suport_dyn}
\end{figure}

Em seguida, foram criadas as rodas traseiras do robô, como demonstradas na figura ~\ref{fig:roda_} abaixo, responsáveis por transmitir a tração dos motores e movimentar a estrutura. Sua geometria foi pensada de forma em que sejam encaixadas no flange do Dynamixel com quatro parafusos para a fixação. Um parafuso adicional será utilizado para conectar a roda ao eixo.

\begin{figure}[h!]
	\centering
	\includegraphics[width=6cm, height=6cm, angle=0]{roda_.jpg}\\
	\caption{Peça Roda Traseira \\ Fonte: Autores, 2019}
	\label{fig:roda_}
\end{figure}

Com as duas rodas traseiras sendo as únicas responsáveis pela tração, foi necessário criar um sistema de roda boba na parte frontal do robô, para que este consiga se deslocar em qualquer direção com a devida sustentação. Para isso, foi criado uma peça
a ser fixada no chassi principal que terá a função de segurar uma esfera, que servirá de roda boba. Uma peça menor será responsável por manter a esfera sempre em contato com o chão, empurrando-a de cima para baixo. Essas peças estão demonstradas na figura~\ref{fig:roda_boba} abaixo, e o esquema para montar esse subsistema está demonstrado na imagem~\ref{fig:roda_boba_montado} abaixo.

\begin{figure}[h!]
	\centering
	\includegraphics[width=8cm, height=7.5cm, angle=0]{roda_boba.png}\\
	\caption{Peças da Roda Boba \\ Fonte: Autores, 2019}
	\label{fig:roda_boba}
\end{figure}

\begin{figure}[h!]
	\centering
	\includegraphics[width=9cm, height=7cm, angle=0]{roda_boba_montado.jpg}\\
	\caption{Montagem da Roda Boba \\ Fonte: Autores, 2019}
	\label{fig:roda_boba_montado}
\end{figure}

Todo esse conjunto será fixado primeiramente no Chassi 3, que tem como função conectar o conjunto da roda boba ao chassi principal e servir de base para o primeiro conversor DC-DC. O conversor DC-DC tem a função de regular a tensão da bateria que sai a 14,4V e precisa chegar ao Raspberry com 5V.

Com a parte inferior do robô finalizada, deu-se início a construção da parte superior, onde fica o cérebro do robô, o Raspberry Pi. Para servir de base para o Raspberry e de cobertura para a bateria, o Chassi 2 foi criado, como mostrado na figura~\ref{fig:chassi_2}

\begin{figure}[h!]
	\centering
	\includegraphics[width=9cm, height=7cm, angle=0]{chassi_2.png}\\
	\caption{Peça Chassi 2 \\ Fonte: Autores, 2019}
	\label{fig:chassi_2}
\end{figure}

Foram alocados quatro furos para segurar a Raspberry, dois furos para o segundo conversor DC-DC e mais quatro furos para a fixação no chassi principal. O Raspberry Pi funciona como um mini computador, o qual terá os códigos e informações necessárias para acionar os
motores.

Por fim, uma capa foi criada para proteger a Raspberry e o conversor da parte superior, além de dar um aspecto moderno ao robô, com linhas diagonais simulando uma seta para frente, como demonstrado na figura~\ref{fig:capa_learn} abaixo. Em frente a capa foi deixado um espaço para a Webcam, que fará as filmagens e auxiliará o sistema a interpretar as imagens com a visão computacional. Ao lado foi feito um corte para permitir a passagem dos conectores HDMI e Micro USB ao Raspberry Pi.

\begin{figure}[h!]
	\centering
	\includegraphics[width=11cm, height=7cm, angle=0]{capa_learn.jpg}\\
	\caption{Peça Capa Superior \\ Fonte: Autores, 2019}
	\label{fig:capa_learn}
\end{figure}

Como mencionado anteriormente, o robô foi pensado para que em sua grande maioria, com exceção de componentes já prontos e peças de fixação como parafusos e porcas, fosse fabricado através de manufatura aditiva.

Essa decisão se justifica devido ao fato de que o proposto por essa abordagem de ensino tem como finalidade ser democrática e abrangente para diversos públicos. A utilização de Impressoras 3D para fabricação das peças do robô é fundamental para essa questão, uma vez que possibilita que qualquer pessoa que possua uma impressora, seja capaz de fabricar as peças e utilizar o kit.

Após fabricação concluída, disponibilização dos componentes de fixação, disponibilização dos componentes eletrônicos e dos dispositivos utilizados no kit, todos os componentes que se tem no robô estão listados abaixo:
\begin{itemize}
	\item 2 Servomotores Dynamixel MX-28
	\item 2 Chassis (1 e 2)
	\item 1 Capa do robô
	\item 2 Suporte para os Servomotores
	\item 2 Rodas traseiras
	\item 2 Flanges Dynamixel
	\item 1 Esfera de 15mm
	\item 1 "EmpurraEsfera"
	\item 1 "SeguraEsfera"
	\item 1 Raspberry Pi 3 b+
	\item 1 Webcam
	\item 1 Bateria Inspired Energy
	\item 2 Conversores DC-DC
	\item 12 Porcas M2.5
	\item 2 Porcas M3
	\item 16 Parafusos de cabeça escareada M2.5 de 12mm
	\item 4 Parafusos de cabeça escareada M2.5 de 25mm
	\item 8 Parafusos Allen de cabeça cilíndrica 3-48 1/2"
	\item 2 Parafusos Allen de cabeça cilíndrica 3-48 7/16"
	\item 2 Parafusos Allen de cabeça escareada M3 de 6mm
	\item 8 Parafusos Allen de cabeça cilíndrica M2.5 de 4mm
\end{itemize}
Com todos os componentes em mãos, o estudante pode proceder para a montagem acompanhando o passo a passo disponibilizado no tutorial de montagem do robô. O resultado da montagem do robô pode ser visualizado na figura ~\ref{fig:learnbotics_rend} a seguir.
\begin{figure}[h!]
	\centering
	\includegraphics[width=12cm, height=10cm, angle=0]{learnbotics_rend.jpg}\\
	\caption{Robô Completo \\ Fonte: Autores, 2019}
	\label{fig:learnbotics_rend}
\end{figure}

\subsection{Raspberry e o SO}

Muito dos componentes apresentados na tabela \ref{Tabela1} são comumente utilizados, tendo uma alta qualidade atrelada, porém, somente quando atreladas à um uso comum. Como o projeto deste trabalho envolvia o uso de uma raspberry, tornou-se necessário o teste de integração entre os componentes e a raspberry.

Para a utilização dos ROS e OpenCV é preferível que estes estejam instalados em um SO (Sistema Operacional) com base em LINUX e com suporte ao ROS e OpenCV. Inicialmente foi testado o Ubuntu 16.04 server. Este SO é um derivativo do Ubuntu 16.04, a única diferença é que este não compõe a parte gráfica. Teoricamente, o Ubuntu server seria o Sistema operacional perfeito para a aplicação deste trabalho, por ser um sistema sólido, amplamente testado e que tem um dos melhores suportes às ferramentas utilizadas. Com tudo, há um pequeno problema na utilização dele, que não há suporte gráfico, ou seja, o aluno de cara teria um grande estranhamento de apenas utilizar o terminal para conseguir fazer as aplicações e desafios compostos no kit.

Com isso, foi preferível instalar o SO Raspbian, uma derivação do Debian. O Raspbian é um sistema operacional otimizado e próprio para a Raspberry, tendo suporte para ROS e OpenCV. Não é possível instalar o SO Ubuntu 16.04 com gráficos pois, a Raspberry não consegue comportar ele, já que ela conta com uma memória gráfica limitada.

O que é interessante neste SO que ele é disponibilizado pela própria Raspberry e mantido por ela. Com isso, este sistema vem com diversas aplicações educacionais, e possíveis projetos que se o aluno quiser explorar, poderá encontrar infinitas finalidades.

Para instalação do SO na Raspberry, foram utilizados os seguintes materiais, mostrados na figura \ref{fig:SO}:

\begin{enumerate}
	\item Raspberry PI 3B+
	\item Cartão SD 32 GB
	\item Imagem do Sistema Operacional
	
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8, angle=0]{Figures/so.png}
	\caption{Componentes necessários para instalar o SO}
	\label{fig:SO}
	\source{Autores modificado, 2019}
\end{figure}

A instalação do SO em si foi seguindo o tutorial disposto no próprio site da \cite{RASPB}, o raspberrypi.org. Lá contém tudo que é necessário para instalar, os passos a serem seguidos e como otimizar a Raspberry.
\subsubsection{ROS para Raspberry}
Para o comprimento dos requisitos funcionais do kit, faz-se necessário a instalação do framework de robótica ROS. Este passo normalmente é fácil e intuitivo, porém, quando se trata de uma ARM (Advanced RISC Machine) a instalação de frameworks como este tornam-se mais complexo. Esta dificuldade é consequência por dois fatores:

\begin{enumerate}
	\item A arquitetura é mais simples se comparado com processadores utilizados em computadores pessoais;
	\item O Sistema Operacional (SO) utilizado é o Raspbian, um SO baseado em Linux próprio para a Raspberry.
\end{enumerate}

Por conta destes dois fatores, a instalação do framework não pode ser feita da mesma forma que é em um computador normal. Felizmente, há diversos tutoriais disponíveis na Internet para o auxílio desta tarefa, porém, isso não fez diminuir o nível esforço para o comprimento dela.

Tendo em vista esta complexidade, a equipe repensou como iria entregar o kit, mudando assim o requisito que o aluno deveria instalar o ROS na Raspberry. O que é interessante analisar é que o intuito deste trabalho é apresentar de forma fácil e prática o mundo da robótica aplicada para os alunos, então, para que não houvessem desistências prematuras do curso, foi preferido entregar o ROS já incluso.
\subsubsection{Instalação do ROS na Raspberry}

Inicialmente, foi utilizado o SO Ubuntu 16.04 server. Neste sistema a instalação do framework ROS foi simples, já que este sistema é amplamente utilizado pela comunidade, sendo assim, tem uma maior suporte.

Para ele, foi feito uma conexão via SSH, utilizando as entradas TX-RX da raspberry. Este tipo de conexão facilita a instalação, já que, pela raspberry somente havia o terminal, já que não havia a parte gráfica. A imagem \ref{fig:txrx} abaixo, mostra os componentes utilizados para a instalação.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8, angle=0]{Figures/TX-RXconexao.png}
	\caption{Componentes necessários para instalar o ROS}
	\label{fig:txrx}
	\source{Autores, 2019}
\end{figure}

Como previamente comentado, foi feito a mudança do Ubuntu para o Raspbian. Com isso, não se fez necessário a conexão por via TX-RX, já que neste caso, havia o componente gráfico no SO.

Para a instalação do ROS no Rasbpian, foi seguido o tutorial disponível no próprio site do ROS, o ROS.org. Porém, houveram alguns problemas com a instalação do Framework neste SO, desde problemas com dependências, com o próprio ROS etc. Estes percalços ocasionaram em um atraso de alguns dias no projeto, já que até então, não eram conhecidos e mapeados.

\subsubsection{Instalação do OPENCV na Raspberry}
Para as aplicações de visão computacional, deve-se utilizar o OpenCV. Este contém inúmeras bibliotecas que viabilizam e possibilitam a identificação de cores, marcos fiduciais etc. Com isso, faz-se necessário a instalação desta ferramenta na Raspberry a fim de possibilitar ao aluno trabalhar com os princípios da visão computacional.

Há inúmeros tutoriais dispostos na internet para a instalação do OpenCV no sistema da Raspberry, especialmente com o Raspbian. Porém, a complexidade é tão alta quanto a instalação do ROS, por isso, a equipe concluiu que tanto o ROS quanto o OpenCV iriam ser entregues instalados na Raspberry.

Para testar se o OpenCV foi instalado corretamente, foi testado um algoritmo simples de identificação de Arucos, o resultado pode ser visto na figura \ref{fig:aruco1} logo abaixo. Este mesmo algoritmo está disposto na WIKI no Github do \cite{wikilearn}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8, angle=0]{Figures/aruco1.png}
	\caption{Aruco de teste}
	\label{fig:aruco1}
	\source{Autores, 2019}
\end{figure}


\subsubsection{Hardware}
Como citado na anteriormente neste trabalho, para que o kit didático seja utilizado de forma modularizada e sem necessidade de uma fonte de tensão variável, foi pensado a utilização de uma batera para alimentar a Raspberry e os motores. Abaixo, a figura \ref{fig:esq_ele} demonstra um diagrama elétrico simplicado do robô.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.6, angle=0]{Figures/diagrama.jpeg}
	\caption{Esquema elétrico}
	\label{fig:esq_ele}
	\source{Autores, 2019}
\end{figure}

A bateria NH2054, tendo o número 1 na figura \ref{fig:esq_ele}, contêm oito células do tamanho de íon de lítio 18650 em um formato de 4 séries e 2 paralelas, dispondo de uma tensão nominal de 14.4V. Entretanto, a tensão pode variar de 16.8 V, quando totalmente carregada e 9.6 V em \textit{cut-off}. Esta variação pode vir a queimar os dynamixels, já que a tensão de trabalho deles é de 10 a 14.8 V, sendo recomendada 12 V, como pode ser visto na figura \ref{fig:dyna_config}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7, angle=0]{Figures/dynamixel_config.png}
	\caption{Esquema elétrico}
	\label{fig:dyna_config}
	\source{Robotis}
\end{figure}

Tendo isso em vista, foi pensado a utilização do conversor DC DC XL6019 (Número 03), ele é um \textit{stepdown BUST}, o que significa que mesmo a bateria alcançando tensões menores que 12 V, o conversor irá suprir os dynamixels sempre com 12 V, o inverso é verdadeiro, quando ocorrer tensões acima de 12 V, o conversor irá energizar os motores com 12V. A figura \ref{fig:nh2054_1} apresenta as informações sobre o XL6019 e suas tensões máximas de entrada e saída. A figura \ref{fig:nh2054_2} apresenta a corrente máxima que o DC DC pode fornecer, isso foi uma preocupação já que ele irá suprir os dois dynamixels.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7, angle=0]{Figures/NH2054_1.png}
	\caption{Informações sobre o conversor NH2054}
	\label{fig:nh2054_1}
	\source{Inspired Energy}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7, angle=0]{Figures/NH2054_2.png}
	\caption{Informações sobre o conversor NH2054}
	\label{fig:nh2054_2}
	\source{Inspired Energy}
\end{figure}

A figura \ref{fig:dyna_config} apresentam que um dynamixel mx28 alto torque necessita de 1.7 A, como são dois em série, o total necessário do conjunto é 3.4 A. Como pode ser visto na figura \ref{fig:nh2054_2}, a corrente máxima que o conversor pode oferecer é 5 A, logo, o requisito de corrente é comprido com este conversor.

Percebe-se pela imagem \ref{fig:esq_ele} que há o conversor LM2596 (número 02). Este conversor tem como intuito alimentar a Raspberry com a tensão de 5v. Ele é um \textit{Stepdown}, o que significa que ele só trabalha para reduzir a tensão de operação.

\subsubsection{Calibração dos conversores}
Como citado anteriormente, há a necessidade de uma tensão fixa de alimentação para os motores e a raspberry, tendo isso em vista, foi feita a calibração dos conversores para obter estas tensões de saída.

Para a calibração, foram utilizados os seguintes materiais:

\begin{itemize}
	\item Voltímetro
	\item Fonte variável
	\item Conversor LM2596
	\item Conversor XL6019        
\end{itemize}

A calibração foi feita da seguinte maneira:
\begin{enumerate}
	\item Ajustar a fonte para ter uma tensão de saída de 14.4 V (tensão nominal da bateria)
	\item Conectar a fonte com o conversor;
	\item Medir a tensão de saída do conversor com o voltímetro;
	\item Ajustar a tensão de saída de acordo com o desejado.
\end{enumerate}

O passo quatro é por tentativa e erro, ou seja, para variar a tensão de saída dos conversores, deve-se girar um potenciômetro instalado nos conversores, com isso, o ajuste é feito manualmente.

A figura \ref{fig:con1} apresenta o resultado da calibração do xl6019 e a figura \ref{fig:con2} o LM2596.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4, angle=0]{Figures/conversor1.jpg}
	\caption{Calibração do conversor XL6019}
	\label{fig:con1}
	\source{Autores, 2019}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.4, angle=0]{Figures/conversor2.jpg}
	\caption{Calibração do conversor LM2596}
	\label{fig:con2}
	\source{Autores, 2019}
\end{figure}

\subsubsection{Testes dos Dynamixels na Raspberry}
Os dynamixels tem como principal diferencial a sua conexão com o ROS proveniente da Robotis, a empresa que comercializa estes servos motores. Entretanto, como o ROS para o sistema da Raspberry é limitado e conta com alguns erros de compilação, fez-se necessário o teste dos dynamixels em conexão com a Raspberry. Os seguintes passos foram planejados para serem seguidos:

\begin{enumerate}
	\item Identificação da baudrate dos dynamixels;
	\item Download e compilação do pacote DynamixelSDK para a Raspberry;
	\item Construção dos algoritimos de configuração e launchers;
	\item Teste de conexão via ROS
\end{enumerate}

Estes quatro passos são a metodologia padrão quando há a necessidade de configurar um dynamixel, porém, ao decorrer dos passos, a equipe se deparou com alguns empecilhos:
\begin{itemize}
	\item O pacote DynamixelSDK não era compilado pelo sistema por falta de memória;
	\item A identificação da baudrate não pode ser no sistema do mini computador, já que os programas disponíveis para a identificação não eram otimizados para uma ARM.
\end{itemize}

Para solucionar estes problemas, a configuração dos baudrates dos dynamixels foram feitos em um computador externo utilizando o \cite{mixcell}.
O pacote DynamixelSDK é de suma importancia para a comunicação entre os servo motores e o ROS, com isso, para solucinar o problema de não compilação foi feito um procedimento de compilação em um computador externo com conexão SSH.
Portanto, após a identificação destes problemas, a equipe concluiu que os dynamixels já deveriam estar configurados na entrega do kit, diminuindo assim possíveis problemas.

Para os testes foram utilizados os seguintes materiais:
\begin{itemize}
	\item 02 Dynamixels MX28;
	\item Conector RS-232
	\item FOnte variável
\end{itemize}

A figura \ref{fig:dyna_cone} demonstra como foi feita a conexão entre os dynamixels, fonte e o computador.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8, angle=0]{Figures/dynamixel_conexao.png}
	\caption{Conexão para os dynamixels}
	\label{fig:dyna_cone}
	\source{Robotis}
\end{figure}

A figura \ref{fig:term_dyna} mostra a validação do teste de integração entre o servo-motor e o ROS. Ela mostra os motores dando o feedback de posição, speed etc por via de tópicos do ROS.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8, angle=0]{Figures/terminal_dyna.png}
	\caption{Conexão para os dynamixels}
	\label{fig:term_dyna}
	\source{Autores, 2019}
\end{figure}


\subsection{Material Escrito}
De forma a melhor organizar a elaboração do conteúdo dos tutoriais, uma divisão dos mesmos foi feita de acordo com o assunto abordado, ocasionando assim uma menor abrangência de assuntos a serem pesquisados, de conteúdos a serem concentrados e de novas interpretações a serem elaboradas.

A primeira sessão dos tutoriais conta com os tutoriais de conceitos básicos, e seguiu o processo de elaboração como detalhado a seguir.

Para contextualizar o estudante sobre o que será aprendido no decorrer do kit foi feita uma breve introdução sobre a história dos robôs, de como surgiu a palavra robô até a construção do primeiro sistema robótico, o UNIMATE. Além desta introdução também foi introduzido, de forma simplificada, o funcionamento de um sistema robótico.

Antes do estudante se aprofundar nos estudos da robótica, deverá ter noções básicas acerca dos conceitos a ser apresentados no decorrer do kit. Para isto, foram apresentados os conceitos superficiais da robótica atual: percepção, visão computacional e navegação e mapeamento. Desta forma, já estará familiarizado com os conceitos quando forem aprofundados.

Um outro conceito básico que o estudante deve assimilar é o conceito de algoritimo e programação. Pois a comunicação entre os computadores e os seres humanos se dá através de linguagens de programação, que se utilizam do conceito de algoritmo para desenvolver suas lógicas. Já os robôs são mecanismos gerenciados por sistemas computacionais para resolução de problemas - auxiliam os seres humanos em tarefas complexas ou repetitivas. Portanto é essencial que o aluno desenvolva conhecimentos sobre algoritmo para que assim seja possível alcançar, através dos algoritmos, o desenvolvimento de comandos que o robô executará.

Após essa parte, deu-se início a confecção dos tutoriais sobre conceitos técnicos que o aluno deverá aprender. O primeiro passo, respeito a modularização proposta, foi falar sobre atuação.

Para que o estudante possa compreender de uma forma mais aprofundada o que está fazendo, antes de começar a mexer com os Dynamixels, uma pequena introdução a atuação foi elaborada.

Essa Introdução trata de uma forma simplificada do conceito de atuadores, de tipos de atuadores, de conversão de energia, e apresenta exemplos cotidianos de atuadores explicando seu funcionamento e aprofundando um pouco mais os conceitos de conversão de energia. \cite{tutAtua}

Após ter tido contato com o conceito de atuadores, o estudante irá encontrar também um tutorial que faz uma introdução aos servo-motores inteligentes Dynamixel$^{TM}$.

Neste tutorial são apresentados os servo-motores inteligentes, suas diferenças para servo-motores comuns, suas vantagens sobre os comuns, qual o papel destes servo-motores no robô e no kit físico e mais precisamente porquê escolhemos utilizar os Dynamixels, e não servo-motores comuns. \cite{tutDyna}

Após ter sido apresentado aos dynamixels e ter tido condições de ligá-los, o próximo passo para começar a utilizá-los depende antes dos conceitos e da utilização do framework ROS.

Tendo em vista a ídeia de apresentar ao estudante ferramentas que são de fato utilizadas por profissionais da área, buscamos realizar um material completo sobre as partes iniciais de utilização do framework ROS.

Devido ao nível de conteúdo que é abordado nos tutoriais nativos do ROS, foi feita uma análise de relevância dos conteúdos e uma reescrita completa do conteúdo abordado, trazendo novas abordagens para passar esse conhecimento para o estudante.

Este tutorial foi dividido em quatro partes, sendo elas, em ordem:
\begin{itemize}
	\item Introdução: O que é o ROS e como funciona;
	\item Conceitos Básicos: Apresentação de terminologia e conceitos base utilizados pela comunidade do ROS.
	\item Entendendo como Funciona o ROS: Apresentação de conteúdo novo que foi elaborado com base em analogias para facilitar o entendimento do estudante sobre a ferramenta.
	\item Tutoriais do ROS: Os Tutoriais de fato, onde o aluno irá aprender a configurar e utilizar o ROS.
\end{itemize}

A parte quatro, ou parte dos tutoriais de fato, aborda todos os conceitos de nível iniciante apresentados nos tutoriais oficiais do ROS. Porém estes conceitos foram demonstrados de forma mais simplificada, com linguagem mais simples e de forma acompanhada passo a passo para uma melhor assimilação do estudante.

Todos os tutoriais foram traduzidos do inglês para o poruguês, visando assim facilitar o acesso à uma amostragem maior de estudantes. \cite{tutROS}

Após ter obtido o conhecimento básico sobre o framework ROS em associação com o que foi passado nos tutoriais sobre os servo-motores a sequência foi de apresentar os tutoriais sobre os scripts de cinemática utilizados.

Nesta parte dos tutoriais o estudante terá acesso ao programa que fará com que o seu robô ande. Além disso será ensinado também como o estudante deve proceder para que transforme seu código em um código executável e para rodá-lo.

De forma a estimular o estudante, uma análise mais minusciosa do código, com comentários parte a parte também foi feita. A partir da explicação do que os comandos do programa fazem o estudante terá condições de alterá-lo para concluir etapas e descobrir coisas por si só.

Para finalizar, o tutorial apresenta um desafio para que o estudante de fato assimile o que lhe está sendo proposto, alterando o código e vendo na prática o que isso ocasiona. \cite{tutCinemat}

Após concluída toda a seção de movimentação do robô, passou-se a elaborar a sessão que trata dos conceitos e utilização da visão computacional. 

Para o ensino de visão computacional apresentado na wiki do Github do Learnbotics \cite{wikilearn}, foi-se pensado na explanação dos conceitos de forma branda e intuitiva, já que, conceitos que se relacionam com visão computacional podem torna-se um tanto rebuscados quando buscados na bibliografia. Os principais conceitos abordados foram:
\begin{itemize}
	\item O uso da visão computacional;
	\item Características  (\textit{Features})
	\item Cantos, arestas e linhas (\textit{Corners,edges e lines})
	\item OpenCV
	\item Segmentação e identificação de cores
	\item Marcos fiduciais
	\item Pose
	\item Identificação de arucos
	
\end{itemize}

Os conceitos apresentados são suficientes para o objetivo do trabalho. Após a construção destes textos na wiki \cite{tutVis}, a equipe disponibilizou para uma pequena amostragem de pessoas a fim de receber feedbacks. Dentro desta amostra, haviam pessoas que trabalhavam com o assunto, que conheciam o uso e que não havia conhecimento prévio de visão computacional. Os principais tópicos abordados nos feedbacks foram:

\begin{itemize}
	\item Boa didática;
	\item Maior número de exemplos nos conteúdos abordados
	\item Conceitos apresentados de forma correta e correlacionando com exemplos do cotidiano
	\item Pequenos erros de digitação e ortografia
\end{itemize}

Os feedbacks, em resumo, foram positivos dos três grupos, tendo como consequência o auxílio a equipe a alcançar de forma satisfatória o intuito de explanar satisfatoriamente a área da visão computacional.

Como previamente abordado neste trabalho, um dos métodos de ensino proposto pela equipe foi a apresentação de desafios. Nos tutoriais foram apresentados os conceitos atrelados à desafios. Estes desafios tinham como intuito a validação dos temas abordados. Um exemplo de desafio proposto, foi o de segmentação de cores, no qual o usuário deve segmentar a cor azul. Para que o aluno conseguisse ter êxito neste desafio, a equipe apresentou  um algoritmo de segmentação da cor vermelha, previamente testado. O resultado pode ser observado na figura \ref{fig:vermelho} abaixo:

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75, angle=0]{Figures/vermelho.png}
	\caption{Exemplo de segmentação de cores}
	\label{fig:vermelho}
	\source{Autores, 2019}
\end{figure}

O último passo foi a elaboração de um tutorial de montagem do robô, uma vez que não é interessante apenas fornecer as peças para o aluno e sua ordem de montagem, mas também fornecer uma linha de raciocínio para que o mesmo não se frustre diante da montagem do robô. O tutorial conta ainda com a sugestão das ferramentas que devem ser utilizadas juntamente com as peças específicas.

\subsection{Desafios}
Ao longo do desenvolvimento dos tutoriais, efetuou-se esforços para pensar e configurar desafios que serviriam como marcos para cada etapa em que o estudante conseguisse avançar. 

Nos tutorias de cinemática por exemplo, após o estudante ter contato com os scripts que fazem seus motores andarem para frente, foi proposto como desafio que o estudante fizesse com que os motores fizessem o robô dar uma meia-volta. Esses desafios foram pensados de uma forma que caso o estudante tenha obtido um certo nível básico de proficiência a partir das análises dos programas modelos, ele conseguiria realizá-los com uma simples mudança no código.

Um outro exemplo desses desafios é o desafio contido na parte introdutória de visão computacional. Foi apresentado para o aluno como seria um script para isolamento e segmentação da cor vermelha em uma imagem \ref{fig:vermelho}, e o desafio proposto foi que ele implementasse o mesmo para a cor azul.

O único desafio que teve um tratamento separado, com uma página própria e explicações próprias foi o desafio final, que devido ao fato de englobar todos os conceitos abordados anteriormente, apresenta uma maior complexidade.

Essa complexidade vai além dos conceitos apresentados, mas também por todos os hardwares estarem em funcionamento ao mesmo tempo. Por isso, para o teste deste algoritmo, foi proposto a seguinte metodologia:

\begin{enumerate}
	\item O primeiro teste foi feito apenas em nível de software, a fim de validar a lógica e encontrar possíveis erros;
	\item A próxima etapa foi testar os dynamixels e a webcam utilizando um computador como “cérebro” .
	\item A última etapa foi utilizar todos os componentes: Raspberry, dynamixels, webcam, bateria e conversores DCDC. A figura \ref{fig:testefinal} apresenta como o teste foi feito.
\end{enumerate}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75, angle=0]{Figures/testefinal.png}
	\caption{Mockup de integração}
	\label{fig:testefinal}
	\source{Autores, 2019}
\end{figure}

A figura \ref{fig:def_fin} apresenta como os componentes do kit se comunicam entre si. Inicialmente, a câmera “enxerga” o aruco e o OpenCV segmenta e identifica o aruco. Após a identificação, o algoritmo envia uma mensagem para o ROS com a informação que ali existe um aruco de ID x. Caso o ID do aruco seja o estipulado para que o robô tenha que ir para frente, o ROS envia uma mensagem para o servo-motor Dynamixel para ir para tal posição. Por sua vez, o dynamixel assim que chegar para a posição determinada, enviará uma mensagem para o ROS com a informação da posição.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.75, angle=0]{Figures/desafio_final.png}
	\caption{Diagrama do desafio final}
	\label{fig:def_fin}
	\source{Autores, 2019}
\end{figure}

O que é interessante descrever sobre este último desafio é que a partir da apresentação e o comprimento dele, o aluno tem capacidade suficiente para começar a aprender e assimilar novos conteúdos da área da robótica por si só. Isso pode ser afirmado pois por trás do problema proposto há diversos conceitos, que se assimilados, propicia ao estudante conteúdo suficiente para adentrar outras áreas da robótica. 